// #include <iostream>

// //#include "FileObject.h"

// #include <glm/glm.hpp>
// #include <glm/gtc/matrix_transform.hpp>

// #define ago = 0

// void displayMatrix(const glm::mat4 & matrix)
// {
//     std::cout << "matrix: \n";
//     for (int i = 0; i < 4; i++)
//     {
//         std::cout << matrix[i][0] << "\t\t" << matrix[i][1] << "\t\t" << matrix[i][2] << "\t\t" << matrix[i][3] << "\n";
//     }
// }

// int main(int argc, char const *argv[])
// {
    
//     long long time ago;

//     std::cout << "test \n";

//     glm::vec3 translate(1.0f, 7.0f, 3.0f);

//     glm::mat4 orthoMatrix  = glm::mat4(1.0f);

//     std::cout << "before translate : \n";

//     displayMatrix(orthoMatrix);

//     std::cout << "after translate : \n";

//     orthoMatrix = glm::translate(orthoMatrix, translate);

//     displayMatrix(orthoMatrix);

//     glm::vec3 scale(1.0f, 3.0f, 2.0f);

//     std::cout << "after scale : \n";

//     orthoMatrix = glm::scale(glm::mat4(1.0f), scale) * orthoMatrix;

//     displayMatrix(orthoMatrix);

//     glm::vec3 rotation(0.0f, 1.0f, 0.0f);

//     std::cout << "after rotation : \n";

//     orthoMatrix = glm::rotate(orthoMatrix, glm::radians(360.0f), rotation);

//     displayMatrix(orthoMatrix);

//     std::cout << "end \n";

//     return 0;
// }

#include <iostream>

#include <thread>
#include <vector>
#include <fstream>
#include <string>
#include <map>
#include <unordered_map>


struct Object
{

    std::string keyName = ""; // for show display only
    std::string name = "";
    unsigned int money = 0;

};


typedef std::vector<Object> objectList;

#define MAX_SIZE 4000


struct hashKey
{
    int mainKey;
    int subKey;
};

class hashTable
{

public:


    hashKey getHashKey(const std::string& name, int flag = 0)
    {
        // calculate hash key
        int result = getHashIndex(name);
        hashKey key;
        key.mainKey = result;
        if(flag == 1)
        {
            if(data[key.mainKey].size() == 0)
            {
                key.mainKey = -1;
            } 
        }
        key.subKey = 0;
        if(data[key.mainKey].size() > 0) // this is O(1 + n) n is the time search in map
        {
            key.subKey = subkeyStorage[name];
        }
        return key;
    }
    int getHashIndex(const std::string& name)
    {
        int result = -1;
        // simple hashing shit
        for (auto c : name)
        {
            result += c;
        }
        result = result %  m_maxSize;
        
        return result;
    }
    void insert(const std::string& name, const Object & obj)
    {
        int mainKey = getHashIndex(name);
        int subKey = data[mainKey].size();
        if(subKey > 0)
        {
            subkeyStorage[name] = subKey; // only save when there is a collision
        }
        data[mainKey].push_back(obj);

        std::cout << "inserted value " << name << " at " << mainKey << " : " << subKey << "\n"; 
        std::cout << "Name : " << data[mainKey][subKey].name << " Money : " << data[mainKey][subKey].money << "\n";
    }

    void search(const std::string& name)
    {
        hashKey key = getHashKey(name,1);
        if(key.mainKey == -1)
        {
            std::cout << name << " not found \n"; 
            return;
        }
        std::cout << "Name : " << data[key.mainKey][key.subKey].name << " Money : " << data[key.mainKey][key.subKey].money << "\n";
    }
    void remove(const std::string& name)
    {
        hashKey key = getHashKey(name,1);
        if(key.mainKey == -1)
        {
            std::cout << name << " not found, how can I remove a thing when it not exist \n"; // philisophy shit that generated by AI 
            return;
        }
        data[key.mainKey].erase(data[key.mainKey].begin() + key.subKey);
        subkeyStorage.erase(name);
        
    }

    void init(int tableSize)
    {
        data.reserve(tableSize);
        data.resize(tableSize);
        m_maxSize = tableSize;
    }

    void displayTable()
    {
        std::cout << "******************** TABLE START ***********************************\n";
        for(int i = 0; i < m_maxSize; i++)
        {
            if(data[i].size() > 0)
            {
                std::cout << "[" << i << "] ";
                for (int j = 0; j < data[i].size(); j++) // hell yeah missionary for loop
                {
                    std::cout << "[" << j << "] (" << data[i][j].keyName << ") :";
                    std::cout << data[i][j].name << " has " << data[i][j].money << " $ \t ";
                }
                std::cout << "\n";
            }
        }
        std::cout << "******************** TABLE END ***********************************\n";
    }

    std::string randomString(int length)
    {
        std::string result;
        for(int i = 0; i < length; i++)
        {
            // only genrate a-z and A-Z
            result += (rand() % 2) ? 'A' + rand() % 26 : 'a' + rand() % 26;
        }
        return result;
    }

    void initRandomData(int sample)
    {

        for (int i = 0; i < sample; i++)
        {
            Object obj;
            obj.keyName = randomString(8);
            obj.name = randomString(8);
            obj.money = rand() % 100;
            insert(obj.keyName, obj);
        }
    }

private:
    std::vector<objectList> data;
    std::unordered_map<std::string, int> subkeyStorage;
    int m_maxSize;
};


int main()
{
    // init random seed
    srand(time(NULL));
    hashTable t;
    t.init(1000);
    t.initRandomData(200);


    t.displayTable();


    int input;
    do {
       std::cout << "****** MENU ******* \n";
        std::cout << "1. Insert \n";
        std::cout << "2. Remove \n";
        std::cout << "3. Display \n";
        std::cout << "4. Search \n";
        std::cout << "others . Exit \n";
        std::cout << "select : ";
        std::cin >> input;
        switch(input)
        {
            case 1:
            {
                std::string keynName;
                std::string name;
                int money;
                std::cout << "key name : ";
                std::cin >> keynName;
                std::cout << "name : ";
                std::cin >> name;
                std::cout << "money : ";
                std::cin >> money;
                Object obj;
                obj.keyName = keynName;
                obj.name = name;
                obj.money = money;
                t.insert(name, obj);
                break;
            }
            case 2:
            {
                std::string name;
                std::cout << "name : ";
                std::cin >> name;
                t.remove(name);
                break;
            }
            case 3:
            {
                t.displayTable();
                break;
            }
            case 4:
            {
                std::string name;
                std::cout << "name : ";
                std::cin >> name;
                t.search(name);
                break;
            }
        }

    }while (input >= 0 && input <= 4);

    return 0;
}